package routines;

import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.math.NumberUtils;
import java.util.Random;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.GregorianCalendar;
import java.sql.*;

import static java.lang.Character.isDigit;
import static java.lang.Character.isLetter;

// Each method could have only one input parameter of type String
// Inside the input parameters are concatenated a standard parameters (entityID and value before masking)and parameters defined by user in maskingRules table


public class MaskingMethods {   
// =============================================
// Author:		Piotr K
// Create date: 2023-04-14
// Description:	returnRandomStringGivenLength(<String EntityID, String currentValue>, int minLength, int maxLength)
// 				parameters in <> are given by masking engine, parameters defined in control tables are concatenated after them. 
//				Method return a random String. Length of the string is between two given parameters. 
// =============================================
public static String returnRandomStringGivenLength(String params) {		
	String[] args = params.split("\\;");
	int minLength = NumberUtils.toInt(args[4]);
	int maxLength = NumberUtils.toInt(args[5]);		
	Random random = new Random();		
	String ran = DataMasking.createRandomString(random.nextInt(minLength, maxLength));
    return ran;
}	

// =============================================
// Author:		Piotr K
// Create date: 2023-04-17
// Description:	returnRandomIntRange(<String EntityID, String currentValue>, int minValue, int maxValue)
//	 			parameters in <> are given by masking engine, parameters defined in control tables are concatenated after them. 
//				Method return a random int. Value of the int is between given parameters, minValue inclusive, maxValue exclusive. 
//				minValue <= random < maxValue

// =============================================
public static int returnRandomIntRange(String params) {		
	String[] args = params.split("\\;");
	int minLength = NumberUtils.toInt(args[4]);
	int maxLength = NumberUtils.toInt(args[5]);		
	Random random = new Random();		
	int ran = random.nextInt(minLength, maxLength);
    return ran;
}	
// =============================================
// Author:		Piotr K
// Create date: 2023-04-17
// Description:	ChangeDayAndMonth(<String EntityID, String currentValue>)
//	 			parameters in <> are given by masking engine, parameters defined in control tables are concatenated after them. 
//				Method take year from to be masked field and generate a random day from this year. Do...while loops prevent cases whene generated date is
//				the same as original one.
// =============================================
public static String ChangeDayAndMonth(String params) {		
	String[] args = params.split("\\;");
	String result;
	int year = NumberUtils.toInt(args[3].substring(0, 4));
	do {
		GregorianCalendar gc = new GregorianCalendar();	
        gc.set(gc.YEAR, year);
        int dayOfYear = randBetween(1, gc.getActualMaximum(gc.DAY_OF_YEAR));
        gc.set(gc.DAY_OF_YEAR, dayOfYear);
        DateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd");
	        result = dateFormat.format(gc.getTime());
		} while (args[3].equalsIgnoreCase(result));
		
        return result;
    }	
  private static int randBetween(int start, int end) {
        return start + (int)Math.round(Math.random() * (end - start));
    }
// =============================================
// Author:		Piotr K
// Create date: 2023-04-17
// Description:	ZipCodeMaskingLogic(<String EntityID, String currentValue>)
//		 			parameters in <> are given by masking engine, parameters defined in control tables are concatenated after them. 
//					Method to change last 3 chars in zip code to randomly generated.
// =============================================					
		
  public static String ZipCodeMaskingLogic(String params) {
	  String[] args = params.split("\\;");
	  String originalZip = args[3];
	  int originalZipLength = originalZip.length();
	  String replace = DataMasking.createRandomString(3);
	  String maskedZip = originalZip.substring(0,originalZipLength-3) + replace;
	  return maskedZip;
  }
// =============================================
// Author:		Piotr K, updated: Tomek K @ 2023-04-27
// Create date: 2023-04-17
// Description:	TelephoneNumberMaskingLogic (<String EntityID, String currentValue>)
//		 		parameters in <> are given by masking engine, parameters defined in control tables are concatenated after them. 
//				Method to mask telephone number. First 3 chars will be kept from original, the rest is replaced with randomly generated digits. The total number length is preserved.
// =============================================					
			
  public static String TelephoneNumberMaskingLogic(String params) {
	  String[] args = params.split("\\;");

	  String originalNum = args[3];

	  int modifiedNumLength = ((originalNum.length()-3)<1)?1:(originalNum.length()-3);
	  
	  String min_val = String.valueOf(modifiedNumLength);
	  String max_val = String.valueOf(modifiedNumLength+1);
	  
	  //prepare input string to call another method that generates digits with certain length of string
	  String input_params = ";;;;"+min_val+";"+max_val;
	  String replace = MaskingMethods.returnRandomDigitsGivenLength(input_params);
	  
	  String maskedNum = originalNum.substring(0,3) + replace;			  
	  
	  //System.out.println("Original: "+originalNum+", Replace: "+replace+",Masked: "+maskedNum);
	  return maskedNum;
  }
		  
// =============================================
// Author:		Piotr K
// Create date: 2023-04-18
// Description:	chooseRandomStringFromTable (<String EntityID, String currentValue>, String tableName, String colName, String dbName)
//		 			parameters in <> are given by masking engine, parameters defined in control tables are concatenated after them. 
//					Method to choose random String record from HSQL table. 
// =============================================		
  public static String chooseRandomStringFromTable(String params) {
	  String[] args = params.split("\\;");
	  String tableToUpdate = args[0];
	  String colToUpdate = args[1];
	  String entityID = args[2]; 
	  String dictDbName = args[4];
	  String dictTableName = args[5];
	  String dictColName = args[6];	 
	    
	  try (
	 	         Connection connDict = DriverManager.getConnection("jdbc:hsqldb:mem:"+dictDbName,"SA",""); 
	 	         Statement stmtDict = connDict.createStatement();
			  	 Connection connEntity = DriverManager.getConnection("jdbc:hsqldb:mem:"+dictDbName+entityID,"SA",""); 
	 	         Statement stmtEntity= connEntity.createStatement();
			  
	 	      ) {	    
		  		 // Dictionary read
	 	         String strSelectDict = "SELECT " + dictColName+ " FROM " +dictTableName;	    	 
	 	         ResultSet rset = stmtDict.executeQuery(strSelectDict);	 	         
	 	         ArrayList<String> dictResult = new ArrayList<>(); 	 	         
	 	         
	 	         while(rset.next()) {
    	            String value = rset.getString(dictColName);
    	            dictResult.add(value);  
    	         }
	 	         // Current entity data read
	 	         String strSelectEntity = "SELECT " + colToUpdate+ " FROM " +tableToUpdate;	    	 
	 	         ResultSet rsetEntity = stmtEntity.executeQuery(strSelectEntity);	 	         
	 	         ArrayList<String> entityResult = new ArrayList<>(); 	 	         
	 	         
	 	         while(rsetEntity.next()) {
	 	        	 String value = rsetEntity.getString(colToUpdate);
	 	        	 System.out.println("Iban is: " + value);	
	 	        	 entityResult.add(value);  
	 	         }
	 	         
	 	         connDict.close();
	 	         connEntity.close();
	 	         
	 	         int length = dictResult.size();
	 	         Random random = new Random();
	 	         String maskedIban = dictResult.get(random.nextInt(0, length));
	 	         System.out.println("To masking chosed iban: "+ maskedIban);	
	 	         return maskedIban;
	 	         
	 	      } catch(SQLException ex) {
	 	         ex.printStackTrace();
	 	      }  	
	  
	  return "Street";
  }
//=============================================
//Author:		Piotr K
//Create date:  2023-04-18
//Description:	hashWithChar (<String EntityID, String currentValue>, String char)
//		 		parameters in <> are given by masking engine, parameters defined in control tables are concatenated after them. 
//				Method replace all characters in string with given character
//=============================================		
 public static String hashWithChar(String params) {
	  String[] args = params.split("\\;");
	  String originalValue = args[3];
	  String replaceWith = args[4];
	  String maskedValue = StringUtils.repeat(replaceWith, originalValue.length());
	  
	  return maskedValue;
 }
//=============================================
//Author:		Piotr K
//Create date:  2023-04-18
//Description:	maskEmailAddress (<String EntityID, String currentValue>)
//		 		parameters in <> are given by masking engine, parameters defined in control tables are concatenated after them. 
//				method will hide all characters under the '*' except first letter of email, first letter of the domain, "@ ." and suffix as ".com/.pl"
//=============================================		
 public static String maskEmailAddress(String params) {
     String[] args = params.split("\\;");
     String originalValue = args[3];

     StringBuilder sb = new StringBuilder();
     StringBuffer output = new StringBuffer(110);

     for (char ch: originalValue.toCharArray()) {
         if(isLetter(ch)){
             char ran = randomSeriesForThreeCharacter();
             output.append(ran);
             continue;
         }else if(isDigit(ch)){
             Random random = new Random();
             int ranInt = random.nextInt(0, 10);
             output.append(ranInt);
             continue;
         }else if(ch == '@'){
             output.append('@');
             continue;
         }else if(ch == '.'){
             output.append('.');
             continue;
         }else {
             char ran = randomSeriesForThreeCharacter();
             output.append(ran);
         }
     }

     return output.toString();
 }
 public static char randomSeriesForThreeCharacter() {
     Random r = new Random();
     char c = (char) (r.nextInt(26) + 'a');
     return c;
 }
 
  
//=============================================
//Author:		Piotr K
//Create date: 2023-04-27
//Description:	returnRandomLettersGivenLength(<String EntityID, String currentValue>, int minLength, int maxLength)
//				parameters in <> are given by masking engine, parameters defined in control tables are concatenated after them. 
//				Method return a random String that contains only letters from a-z. Length of the string is between two given parameters. 
//=============================================
public static String returnRandomLettersGivenLength(String params) {		
	int leftLimit = 97; // letter 'a'
    int rightLimit = 122; // letter 'z'
    
    String[] args = params.split("\\;");
	
    int minLength = NumberUtils.toInt(args[4]);
	int maxLength = NumberUtils.toInt(args[5]);	
	
    Random random = new Random();
    int targetStringLength = random.nextInt(minLength, maxLength);
    
    StringBuilder buffer = new StringBuilder(targetStringLength);
    for (int i = 0; i < targetStringLength; i++) {
        int randomLimitedInt = leftLimit + (int) 
          (random.nextFloat() * (rightLimit - leftLimit + 1));
        buffer.append((char) randomLimitedInt);
    }
    String generatedString = buffer.toString();

    //System.out.println(generatedString);
    return generatedString;
	}

//=============================================
//Author:		Piotr K
//Create date: 2023-04-27
//Description:	returnRandomLettersGivenLength(<String EntityID, String currentValue>, int minLength, int maxLength)
//				parameters in <> are given by masking engine, parameters defined in control tables are concatenated after them. 
//				Method return a random String that contains only digits from 0-9. Length of the string is between two given parameters. 
//=============================================
public static String returnRandomDigitsGivenLength(String params) {		
	int leftLimit = 48; // digit 0
  int rightLimit = 57; // digit 9
  
  String[] args = params.split("\\;");
	
  int minLength = NumberUtils.toInt(args[4]);
	int maxLength = NumberUtils.toInt(args[5]);	
	
  Random random = new Random();
  int targetStringLength = random.nextInt(minLength, maxLength);
  
  StringBuilder buffer = new StringBuilder(targetStringLength);
  for (int i = 0; i < targetStringLength; i++) {
      int randomLimitedInt = leftLimit + (int) 
        (random.nextFloat() * (rightLimit - leftLimit + 1));
      buffer.append((char) randomLimitedInt);
  }
  String generatedString = buffer.toString();

  //System.out.println(generatedString);
  return generatedString;
	}
//=============================================
//Author:		Piotr K
//Create date: 2023-04-27
//Description:	returnRandomStringGivenLength(<String EntityID, String currentValue>, double Input_val)
//				parameters in <> are given by masking engine, parameters defined in control tables are concatenated after them. 
//				Method return a fixed value Double type , based on input value. Used mostly for masking geo-location
//=============================================
	public static double maskDouble(String params) {		
	  
	  String[] args = params.split("\\;");
	  
	  double input_val = NumberUtils.toDouble(args[4]);
	  //System.out.println(input_val);
	  return input_val;
	}	
}
