package routines;

import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.math.NumberUtils;
import java.util.Random;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.GregorianCalendar;
import java.sql.*;

// Each method could have only one input parameter of type String
// Inside the input parameters are concatenated a standard parameters (entityID and value before masking)and parameters defined by user in maskingRules table


public class MaskingMethods {   
// =============================================
// Author:		Piotr K
// Create date: 2023-04-14
// Description:	returnRandomStringGivenLength(<String EntityID, String currentValue>, int minLength, int maxLength)
// 				parameters in <> are given by masking engine, parameters defined in control tables are concatenated after them. 
//				Method return a random String. Length of the string is between two given parameters. 
// =============================================
public static String returnRandomStringGivenLength(String params) {		
	String[] args = params.split("\\;");
	int minLength = NumberUtils.toInt(args[2]);
	int maxLength = NumberUtils.toInt(args[3]);		
	Random random = new Random();		
	String ran = DataMasking.createRandomString(random.nextInt(minLength, maxLength));
    return ran;
}	

// =============================================
// Author:		Piotr K
// Create date: 2023-04-17
// Description:	returnRandomIntRange(<String EntityID, String currentValue>, int minValue, int maxValue)
//	 			parameters in <> are given by masking engine, parameters defined in control tables are concatenated after them. 
//				Method return a random int. Value of the int is between given parameters, minValue inclusive, maxValue exclusive. 
//				minValue <= random < maxValue

// =============================================
public static int returnRandomIntRange(String params) {		
	String[] args = params.split("\\;");
	int minLength = NumberUtils.toInt(args[2]);
	int maxLength = NumberUtils.toInt(args[3]);		
	Random random = new Random();		
	int ran = random.nextInt(minLength, maxLength);
    return ran;
}	
// =============================================
// Author:		Piotr K
// Create date: 2023-04-17
// Description:	ChangeDayAndMonth(<String EntityID, String currentValue>)
//	 			parameters in <> are given by masking engine, parameters defined in control tables are concatenated after them. 
//				Method take year from to be masked field and generate a random day from this year. Do...while loops prevent cases whene generated date is
//				the same as original one.
// =============================================
public static String ChangeDayAndMonth(String params) {		
	String[] args = params.split("\\;");
	String result;
	do {
		GregorianCalendar gc = new GregorianCalendar();				
		int year = NumberUtils.toInt(args[1].substring(0, 4));
        gc.set(gc.YEAR, year);
        int dayOfYear = randBetween(1, gc.getActualMaximum(gc.DAY_OF_YEAR));
        gc.set(gc.DAY_OF_YEAR, dayOfYear);
        DateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd");
	        result = dateFormat.format(gc.getTime());
		} while (args[1].equalsIgnoreCase(result));
		
        return result;
    }	
  private static int randBetween(int start, int end) {
        return start + (int)Math.round(Math.random() * (end - start));
    }
// =============================================
// Author:		Piotr K
// Create date: 2023-04-17
// Description:	ZipCodeMaskingLogic(<String EntityID, String currentValue>)
//		 			parameters in <> are given by masking engine, parameters defined in control tables are concatenated after them. 
//					Method to change last 3 chars in zip code to randomly generated.
// =============================================					
		
  public static String ZipCodeMaskingLogic(String params) {
	  String[] args = params.split("\\;");
	  String originalZip = args[1];
	  int originalZipLength = originalZip.length();
	  String replace = DataMasking.createRandomString(3);
	  String maskedZip = originalZip.substring(0,originalZipLength-3) + replace;
	  return maskedZip;
  }
// =============================================
// Author:		Piotr K
// Create date: 2023-04-17
// Description:	TelephoneNumberMaskingLogic (<String EntityID, String currentValue>)
//		 			parameters in <> are given by masking engine, parameters defined in control tables are concatenated after them. 
//					Method to mask telephone number. First 3 chars will be kept from original, the rest is replaced with randomly generated.
// =============================================					
			
  public static String TelephoneNumberMaskingLogic(String params) {
	  String[] args = params.split("\\;");
	  String originalNum = args[1];
	  int originalNumLength = originalNum.length();
	  String replace = DataMasking.createRandomString(originalNumLength-3);
	  String maskedNum = originalNum.substring(0,3) + replace;			  
	  return maskedNum;
  }
		  
// =============================================
// Author:		Piotr K
// Create date: 2023-04-18
// Description:	chooseRandomStringFromTable (<String EntityID, String currentValue>, String tableName, String colName, String dbName)
//		 			parameters in <> are given by masking engine, parameters defined in control tables are concatenated after them. 
//					Method to choose random String record from HSQL table. 
// =============================================		
  public static String chooseRandomStringFromTable(String params) {
	  String[] args = params.split("\\;");
	  String dbName = args[2];
	  String tableName = args[3];
	  String colName = args[4];	 
	  try (
	 	         Connection conn = DriverManager.getConnection("jdbc:hsqldb:mem:"+dbName,"SA",""); 
	 	         Statement stmt = conn.createStatement();
	 	      ) {	    	         
	 	         String strSelect = "SELECT " + colName+ " FROM " +tableName;	    	 
	 	         ResultSet rset = stmt.executeQuery(strSelect);	 	         
	 	         ArrayList<String> valuesResult = new ArrayList<>(); 
	 	         
	 	         while(rset.next()) {
    	            String value = rset.getString(colName);
    	            valuesResult.add(value);  
    	         }
	 	         conn.close();
	 	         int length = valuesResult.size();
	 	         Random random = new Random();
	 	         return valuesResult.get(random.nextInt(0, length));
	 	         
	 	      } catch(SQLException ex) {
	 	         ex.printStackTrace();
	 	      }  	
	  
	  return "Street";
  }
//=============================================
//Author:		Piotr K
//Create date:  2023-04-18
//Description:	hashWithChar (<String EntityID, String currentValue>, String char)
//		 		parameters in <> are given by masking engine, parameters defined in control tables are concatenated after them. 
//				Method replace all characters in string with given character
//=============================================		
 public static String hashWithChar(String params) {
	  String[] args = params.split("\\;");
	  String originalValue = args[1];
	  String replaceWith = args[2];
	  String maskedValue = StringUtils.repeat(replaceWith, originalValue.length());
	  
	  return maskedValue;
 }
//=============================================
//Author:		Piotr K
//Create date:  2023-04-18
//Description:	chooseRandomStringFromTable (<String EntityID, String currentValue>, String tableName, String colName)
//		 			parameters in <> are given by masking engine, parameters defined in control tables are concatenated after them. 
//					method will hide all characters under the '*' except first letter of email, first letter of the domain, "@ ." and suffix as ".com/.pl"
//=============================================		
public static String maskEmailAddress(String params) {
	  String[] args = params.split("\\;");
	  String originalValue = args[1];
	  return originalValue.replaceAll("(?<=.)[^@](?=[^@]*?@)|(?:(?<=@.)|(?!^)\\G(?=[^@]*$)).(?=.*\\.)", "*");	
}
 
  
}
