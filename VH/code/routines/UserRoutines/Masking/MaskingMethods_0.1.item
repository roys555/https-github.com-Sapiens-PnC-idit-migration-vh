package routines;

import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.math.NumberUtils;
import java.util.Random;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.GregorianCalendar;
import java.sql.*;

import static java.lang.Character.isDigit;
import static java.lang.Character.isLetter;

// Each method could have only one input parameter of type String
// Inside the input parameters are concatenated a standard parameters (entityID and value before masking)and parameters defined by user in maskingRules table


public class MaskingMethods {   
// =============================================
// Author:		Piotr K
// Create date: 2023-04-14
// Description:	returnRandomStringGivenLength(<String EntityID, String currentValue>, int minLength, int maxLength)
// 				parameters in <> are given by masking engine, parameters defined in control tables are concatenated after them. 
//				Method return a random String. Length of the string is between two given parameters. 
// =============================================
public static String returnRandomStringGivenLength(String params) {		
	String[] args = params.split("\\;");
	int minLength = NumberUtils.toInt(args[2]);
	int maxLength = NumberUtils.toInt(args[3]);		
	Random random = new Random();		
	String ran = DataMasking.createRandomString(random.nextInt(minLength, maxLength));
    return ran;
}	

// =============================================
// Author:		Piotr K
// Create date: 2023-04-17
// Description:	returnRandomIntRange(<String EntityID, String currentValue>, int minValue, int maxValue)
//	 			parameters in <> are given by masking engine, parameters defined in control tables are concatenated after them. 
//				Method return a random int. Value of the int is between given parameters, minValue inclusive, maxValue exclusive. 
//				minValue <= random < maxValue

// =============================================
public static int returnRandomIntRange(String params) {		
	String[] args = params.split("\\;");
	int minLength = NumberUtils.toInt(args[2]);
	int maxLength = NumberUtils.toInt(args[3]);		
	Random random = new Random();		
	int ran = random.nextInt(minLength, maxLength);
    return ran;
}	
// =============================================
// Author:		Piotr K
// Create date: 2023-04-17
// Description:	ChangeDayAndMonth(<String EntityID, String currentValue>)
//	 			parameters in <> are given by masking engine, parameters defined in control tables are concatenated after them. 
//				Method take year from to be masked field and generate a random day from this year. Do...while loops prevent cases whene generated date is
//				the same as original one.
// =============================================
public static String ChangeDayAndMonth(String params) {		
	String[] args = params.split("\\;");
	String result;
	int year = NumberUtils.toInt(args[1].substring(0, 4));
	do {
		GregorianCalendar gc = new GregorianCalendar();	
        gc.set(gc.YEAR, year);
        int dayOfYear = randBetween(1, gc.getActualMaximum(gc.DAY_OF_YEAR));
        gc.set(gc.DAY_OF_YEAR, dayOfYear);
        DateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd");
	        result = dateFormat.format(gc.getTime());
		} while (args[1].equalsIgnoreCase(result));
		
        return result;
    }	
  private static int randBetween(int start, int end) {
        return start + (int)Math.round(Math.random() * (end - start));
    }
// =============================================
// Author:		Piotr K
// Create date: 2023-04-17
// Description:	ZipCodeMaskingLogic(<String EntityID, String currentValue>)
//		 			parameters in <> are given by masking engine, parameters defined in control tables are concatenated after them. 
//					Method to change last 3 chars in zip code to randomly generated.
// =============================================					
		
  public static String ZipCodeMaskingLogic(String params) {
	  String[] args = params.split("\\;");
	  String originalZip = args[1];
	  int originalZipLength = originalZip.length();
	  String replace = DataMasking.createRandomString(3);
	  String maskedZip = originalZip.substring(0,originalZipLength-3) + replace;
	  return maskedZip;
  }
// =============================================
// Author:		Piotr K
// Create date: 2023-04-17
// Description:	TelephoneNumberMaskingLogic (<String EntityID, String currentValue>)
//		 			parameters in <> are given by masking engine, parameters defined in control tables are concatenated after them. 
//					Method to mask telephone number. First 3 chars will be kept from original, the rest is replaced with randomly generated.
// =============================================					
			
  public static String TelephoneNumberMaskingLogic(String params) {
	  String[] args = params.split("\\;");
	  String originalNum = args[1];
	  int originalNumLength = originalNum.length();
	  String replace = DataMasking.createRandomString(originalNumLength-3);
	  String maskedNum = originalNum.substring(0,3) + replace;			  
	  return maskedNum;
  }
		  
// =============================================
// Author:		Piotr K
// Create date: 2023-04-18
// Description:	chooseRandomStringFromTable (<String EntityID, String currentValue>, String tableName, String colName, String dbName)
//		 			parameters in <> are given by masking engine, parameters defined in control tables are concatenated after them. 
//					Method to choose random String record from HSQL table. 
// =============================================		
  public static String chooseRandomStringFromTable(String params) {
	  String[] args = params.split("\\;");
	  String dbName = args[2];
	  String tableName = args[3];
	  String colName = args[4];	 
	  try (
	 	         Connection conn = DriverManager.getConnection("jdbc:hsqldb:mem:"+dbName,"SA",""); 
	 	         Statement stmt = conn.createStatement();
	 	      ) {	    	         
	 	         String strSelect = "SELECT " + colName+ " FROM " +tableName;	    	 
	 	         ResultSet rset = stmt.executeQuery(strSelect);	 	         
	 	         ArrayList<String> valuesResult = new ArrayList<>(); 
	 	         
	 	         while(rset.next()) {
    	            String value = rset.getString(colName);
    	            valuesResult.add(value);  
    	         }
	 	         conn.close();
	 	         int length = valuesResult.size();
	 	         Random random = new Random();
	 	         return valuesResult.get(random.nextInt(0, length));
	 	         
	 	      } catch(SQLException ex) {
	 	         ex.printStackTrace();
	 	      }  	
	  
	  return "Street";
  }
//=============================================
//Author:		Piotr K
//Create date:  2023-04-18
//Description:	hashWithChar (<String EntityID, String currentValue>, String char)
//		 		parameters in <> are given by masking engine, parameters defined in control tables are concatenated after them. 
//				Method replace all characters in string with given character
//=============================================		
 public static String hashWithChar(String params) {
	  String[] args = params.split("\\;");
	  String originalValue = args[1];
	  String replaceWith = args[2];
	  String maskedValue = StringUtils.repeat(replaceWith, originalValue.length());
	  
	  return maskedValue;
 }
//=============================================
//Author:		Piotr K
//Create date:  2023-04-18
//Description:	maskEmailAddress (<String EntityID, String currentValue>)
//		 		parameters in <> are given by masking engine, parameters defined in control tables are concatenated after them. 
//				method will hide all characters under the '*' except first letter of email, first letter of the domain, "@ ." and suffix as ".com/.pl"
//=============================================		
 public static String maskEmailAddress(String params) {
     String[] args = params.split("\\;");
     String originalValue = args[1];

     StringBuilder sb = new StringBuilder();
     StringBuffer output = new StringBuffer(110);

     for (char ch: originalValue.toCharArray()) {
         if(isLetter(ch)){
             char ran = randomSeriesForThreeCharacter();
             output.append(ran);
             continue;
         }else if(isDigit(ch)){
             Random random = new Random();
             int ranInt = random.nextInt(0, 10);
             output.append(ranInt);
             continue;
         }else if(ch == '@'){
             output.append('@');
             continue;
         }else if(ch == '.'){
             output.append('.');
             continue;
         }else {
             char ran = randomSeriesForThreeCharacter();
             output.append(ran);
         }
     }

     return output.toString();
 }
 public static char randomSeriesForThreeCharacter() {
     Random r = new Random();
     char c = (char) (r.nextInt(26) + 'a');
     return c;
 }
 
  
//=============================================
//Author:		Piotr K
//Create date: 2023-04-14
//Description:	returnRandomStringGivenLength(<String EntityID, String currentValue>, int minLength, int maxLength)
//				parameters in <> are given by masking engine, parameters defined in control tables are concatenated after them. 
//				Method return a random String. Length of the string is between two given parameters. 
//=============================================
public static String returnRandomLettersGivenLength(String params) {		
	int leftLimit = 97; // letter 'a'
    int rightLimit = 122; // letter 'z'
    
    String[] args = params.split("\\;");
	
    int minLength = NumberUtils.toInt(args[2]);
	int maxLength = NumberUtils.toInt(args[3]);	
	
    Random random = new Random();
    int targetStringLength = random.nextInt(minLength, maxLength);
    
    StringBuilder buffer = new StringBuilder(targetStringLength);
    for (int i = 0; i < targetStringLength; i++) {
        int randomLimitedInt = leftLimit + (int) 
          (random.nextFloat() * (rightLimit - leftLimit + 1));
        buffer.append((char) randomLimitedInt);
    }
    String generatedString = buffer.toString();

    //System.out.println(generatedString);
    return generatedString;
	}	
}
